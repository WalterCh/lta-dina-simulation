---
title: "Explicacion de dina_analysis.R"
author: "Walter Chanavá"
date: "23/7/2020"
output: 
  html_document:
    df_print: paged
    fig_caption: true
    toc: true
    toc_float: true
    number_sections: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,
                      message = F,
                      error = F,
                      fig.align = 'center',
                      warning = F)
load("~/walteR/lta-dina-simulation/R-Scripts/environment.RData")
```

## *dina_analysis.R* por partes:



```{r, eval=FALSE}
# Data Simulation ---------------------------------------------------------

# function in Scripts/data_sim_function.R
source("Dina_simulation_function.R")
```

La funcion `source` permite ejecutar un script por completo que se encuentre en el mismo directorio de trabajo (es por eso que no se especifica la ruta completa, solo el nombre del script.). Al ejecutar un script dentro de otro script lo que permite es que se almacenen las variables que se encontraban en `Dina_simulation_function.R` (en ese script se encuentra la funcion que simula los datos) sin necesidad de agregarlas al inicio.

```{r}
# Q- matrix
Q <- matrix(c(1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,
              1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,
              1,1,0,1,0,1,1,0,0,1,1,0,0,0), 
            ncol = 4, nrow = 20, byrow = TRUE)
Q
```

Luego se almacena los datos de la matriz Q (20x4) en el objeto `Q`.

```{r, eval=FALSE}
dina <- dina_data_sim(slip_guess_min = .1, slip_guess_max = .3, Q = Q)
```

Con la funcion `dina_data_sim()` (que proviene del script `Dina_simulation_function.R`) se generan los datos con los limites de `slip` y `guess` entre 0.1 y 0.3, tambien es necesario ingresar la matriz Q para la simulacion, y se guarda la simulacion en el objeto `dina` (La lista contien los objetos `r names(dina)`). 

```{r, echo=FALSE}
# Packages
library(MplusAutomation)
library(dplyr)
library(ggplot2)
library(extrafont)
library(latex2exp)
```

Paquetes necesarios para el analisis:

- MplusAutomation: paquete que permite usar Mplus con R.
- dplyr: paquete de manejo de datos.
- ggplot2: paquete para visualizar los datos.
- extrafont: paquete que permite cambiar de fuente en los graficos ggplot2.
- latex2exp: permite usar latex en los ejes de los graficos ggplot2 (No funciona con las leyendas).

```{r, eval=FALSE}
# Preparing data
prepareMplusData(dina$sim_dina, "../Data/lta_dina.dat")
```

Esta funcion *exporta* la simulacion a un archivo `lta_dina.dat` en formato `.dat`.

```{r, eval=FALSE}
# Model
runModels("C:/Users/Usuario/Dropbox/Dina/mplus", showOutput = TRUE)
output2 <- readModels("C:/Users/Usuario/Dropbox/Dina/mplus/lta_dina.out")
```

Estas funciones permiten correr el modelo desde R, usando Mplus como subproceso y con `readModels` almacena el output como un solo objeto de R (formato lista).

```{r, eval=FALSE}
# Savedata analysis
savedata <- as.tbl(output2$savedata)
savedata_prof <- savedata %>%
  select(C1:C8) %>% 
  mutate(C1 = ifelse(C1 == 2, 1, 0), # 2 es dominio y 1 es no dominio
         C2 = ifelse(C2 == 2, 1, 0),
         C3 = ifelse(C3 == 2, 1, 0),
         C4 = ifelse(C4 == 2, 1, 0),
         C5 = ifelse(C5 == 2, 1, 0),
         C6 = ifelse(C6 == 2, 1, 0),
         C7 = ifelse(C7 == 2, 1, 0),
         C8 = ifelse(C8 == 2, 1, 0))
```

Desde aqui se empieza a manipular los datos del output para las tablas.

```{r, eval=FALSE}
# tabla 4.4
p_transic <- tibble("Habilidades" = c("Número y Operaciones", "Medición", 
                         "Solución de problemas", "Representación"),
                    p_t1 = c(mean(dina$alphas$V2), mean(dina$alphas$V3),
                             mean(dina$alphas$V4), mean(dina$alphas$V5)),
                    p_t2 = c(mean(dina$alphas$V6), mean(dina$alphas$V7),
                             mean(dina$alphas$V8), mean(dina$alphas$V9)))
write.csv(p_transic, "./Tablas/P_Transicion.csv")
```

```{r, collapse=TRUE}
p_transic
```

Se genera la primera tabla usando los `alphas` (parametros de la simulacion, los interpretamos como perfiles de cada alumno, ya que la matriz de `alphas` es de 1000x40). La funcion `write.csv` exporta la tabla como `P_Transicion.csv`.

```{r, eval=FALSE}
# 4.5
Q_tbl <- as.tbl(as.data.frame(Q)) 

prof_comb <- Q_tbl %>% 
  mutate(comb = paste0(V1, V2, V3, V4)) %>% 
  group_by(comb) %>%
  summarise(n = n()) %>% 
  pull(comb)
```

```{r, collapse=TRUE}
prof_comb
```

Se convierte la matrix `Q` a un objeto dataframe de tipo `tbl` (para mejor uso manipulacion de los datos).

Con `dplyr` agrega una columna `comb` con los perfiles, los agrupa, hace un conteo por grupos y retira como vector cuales son los perfiles que mide el 

```{r, eval=FALSE}
alphas <- as.tbl(dina$alphas) %>% 
  select(-id)
colnames(alphas) = c(paste0("X", 1:4), paste0("Y", 1:4))
```

```{r, collapse=TRUE}
alphas
```


Se toman las alphas de la simulacion, se les quita el `id` y se cambian los nombres de las columnas de X para las habilidades en tiempo1 y Y para el tiempo 2

```{r, eval=FALSE}

alphas_t1 <- alphas %>% 
  select(X1:X4) %>% 
  mutate(comb = paste0(X1, X2, X3, X4)) %>%  
  group_by(comb) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n))

alphas_t2 <- alphas %>% 
  select(Y1:Y4) %>% 
  mutate(comb = paste0(Y1, Y2, Y3, Y4)) %>%  
  group_by(comb) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n))

write.csv(alphas_t1, "./Tablas/Frec_Prop_T1.csv")
write.csv(alphas_t2, "./Tablas/Frec_Prop_T2.csv")
```

